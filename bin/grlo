#!/usr/bin/python
# Hyperparameter optimization

import yaml, sys, copy, string, math, random
from grllib import *

srv = Server()

def line_search(conf, param, values, repetitions, regret):
  print "Optimizing", param

  vworkers = {}
  for v in values:
    newconf = copy.deepcopy(conf)
    setparam(newconf, param, v)
    confstr = yaml.dump(newconf)
    
    vworkers[v] = [srv.submit(confstr) for r in range(repetitions)]
    
    print "Submitted", v
  
  vresults = {}
  for value, workers in vworkers.iteritems():
    results = [readWorker(w, regret) for w in workers]
    
    avg = sum(results)/len(results)
    stddev = math.sqrt(sum([(r-avg)**2 for r in results])/(len(results)-1))
    stderr = stddev/math.sqrt(len(results))
    
    print value, (avg, stddev, stderr)

    vresults[value] = (avg, stddev, stderr)
    
  return vresults

def staged_optimize(cfg, spec, conf):
  print "Staged random search"

  for round in range(spec["rounds"]):
    # Create initial configurations
    pop = []
    runs = 1
    max_runs = 100
    fact = 10
    repetitions = spec["repetitions"]
    
    for i in range(repetitions):
      newconf = copy.deepcopy(conf)
      for p in spec["parameters"]:
        setparam(newconf, p["name"], p["values"][random.randrange(len(p["values"]))])
      pop.append(newconf)
  
    while True:
      print "Submitting", repetitions, "configurations with", runs, "runs each"
    
      # Submit jobs
      workers = [(c, [srv.submit(yaml.dump(c)) for r in range(runs)]) for c in pop]
      
      # Gather results
      results = []  
      for (c, cworkers) in workers:
        cresults = [readWorker(w, spec["regret"]) for w in cworkers]
        
        avg = sum(cresults)/len(cresults)
        
        if len(cresults) > 1:
          stddev = math.sqrt(sum([(r-avg)**2 for r in cresults])/(len(cresults)-1))
          stderr = stddev/math.sqrt(len(cresults))
        else:
          stddev = 0
          stderr = 0
          
        results.append((c, avg, stddev, stderr))
        
        # Save
        resconf = {}
        resconf["runs"] = runs
        resconf["mean"] = avg
        resconf["stddev"] = stddev
        resconf["stderr"] = stderr
        c["results"] = resconf
        
        outfile = cfg[:-5] + '-' + str(round) + '-' + str(runs) + '-' + str(len(results)-1) + '.yaml'
        stream = open(outfile, 'w')
        yaml.dump(c, stream)
        stream.close()
        
      # Sieve
      results = sorted(results, key=lambda (c, avg, stddev, stderr): avg-1.96*stderr, reverse=True)
      if len(results) >= fact:
        results = results[0:len(results)/fact]
        
      print "Best result has score", results[0][1]-1.96*results[0][3]
      
      pop = [c for (c, avg, stddev, stderr) in results]
      
      if runs == max_runs:
        break
      
      runs *= fact
      if runs > max_runs:
        runs = max_runs
      repetitions = int(spec["repetitions"]/runs)
  
def random_optimize(cfg, spec, conf):
  print "Random search"

  bestscore = -100000
  bestout = cfg[:-5] + '-best.yaml'
  it = 0
  
  while it < spec["rounds"]:
    workers = []
    for i in range(max(1, int(100/spec["repetitions"]))):
      newconf = copy.deepcopy(conf)
      for p in spec["parameters"]:
        setparam(newconf, p["name"], p["values"][random.randrange(len(p["values"]))])
      confstr = yaml.dump(newconf)
      
      print "Submitting new configuration"
      workers.append((newconf, [srv.submit(confstr) for r in range(spec["repetitions"])]))

    for (c, cworkers) in workers:
      results = [readWorker(w, spec["regret"]) for w in cworkers]
      
      avg = sum(results)/len(results)
      stddev = math.sqrt(sum([(r-avg)**2 for r in results])/(len(results)-1))
      stderr = stddev/math.sqrt(len(results))
      
      resconf = {}
      resconf["mean"] = avg
      resconf["stddev"] = stddev
      resconf["stderr"] = stderr
      c["results"] = resconf
      
      outfile = cfg[:-5] + '-' + str(it) + '.yaml'
      stream = open(outfile, 'w')
      yaml.dump(c, stream)
      stream.close()
      
      score = avg-1.96*stderr
      
      if score > bestscore:
        print "Found new best lower confidence margin", score
        bestscore = score
        stream = open(bestout, 'w')
        yaml.dump(conf, stream)
        stream.close()

      it += 1

def line_optimize(cfg, spec, conf):
  it = 0
  
  for round in range(spec["rounds"]):
    for p in spec["parameters"]:
      results = line_search(conf, p["name"], p["values"], spec["repetitions"], spec["regret"])
      
      means = [avg for (avg, stddev, stderr) in results.values()]
      best = [v for v, (avg, stddev, stderr) in results.items() if avg == max(means)]
      
      print "Chose", best[0]
    
      setparam(conf, p["name"], best[0])
      
      resconf = {}
      resconf["parameter"] = p["name"]
      resconf["values"] = [v for v, (avg, stddev, stderr) in results.items()]
      resconf["mean"] = [avg for v, (avg, stddev, stderr) in results.items()]
      resconf["stddev"] = [stddev for v, (avg, stddev, stderr) in results.items()]
      resconf["stderr"] = [stderr for v, (avg, stddev, stderr) in results.items()]
      
      bestconf = {}
      bestconf["value"] = best[0]
      bestconf["mean"] = results[best[0]][0]
      bestconf["stddev"] = results[best[0]][1]
      bestconf["stderr"] = results[best[0]][2]
      
      resconf["best"] = bestconf
      conf["results"] = resconf
      
      outfile = cfg[:-5] + '-' + str(it) + '.yaml'
      stream = open(outfile, 'w')
      yaml.dump(conf, stream)
      stream.close()
      it += 1
    
    # Stopping criterion?

if __name__ == '__main__':
  cfg = 'optimize.yaml'
  if len(sys.argv) > 1:
    cfg = sys.argv[1]

  stream = open(cfg, 'r')
  spec = yaml.load(stream)
  stream.close()
  
  file = spec["file"]
  stream = open(file, 'r')
  conf = yaml.load(stream)
  stream.close()
  
  if spec["algorithm"] == 'line':
    line_optimize(cfg, spec, conf)
  elif spec["algorithm"] == 'random':
    random_optimize(cfg, spec, conf)
  elif spec["algorithm"] == 'staged':
    staged_optimize(cfg, spec, conf)
  else:
    raise Exception("Unknown optimization algorithm " + spec["algorithm"])
